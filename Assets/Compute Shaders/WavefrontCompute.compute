#pragma kernel WavefrontPlannerKernel
#pragma kernel WavefrontInitNodesKernel

#include "HLSLSupport.cginc"

#define GROUP_SIZE_X 32
#define GROUP_SIZE_Y 8
#define SHARED_ARRAYS_SIZE_X (GROUP_SIZE_X + 2)
#define SHARED_ARRAYS_SIZE_Y (GROUP_SIZE_Y + 2)
#define SHARED_ARRAYS_SIZE (SHARED_ARRAYS_SIZE_X * SHARED_ARRAYS_SIZE_Y)
#define NUM_SHARED_HALO_NODES (2 * (GROUP_SIZE_X + GROUP_SIZE_Y + 2))

#define NODES_WIDTH_INCLUDING_HALO (nodesWidth + 2)
#define NODES_1D_INDEX(i, j) ((i) + NODES_WIDTH_INCLUDING_HALO * (j))

#define EDGE_NW(i, j) edgesLeftDiag[(i) - 1 + ((j) - 1) * (nodesWidth + 1)]
#define EDGE_N(i, j) edgesVert[(i) + ((j) - 1) * (nodesWidth + 1)]
#define EDGE_NE(i, j) edgesRightDiag[(i) + ((j) - 1) * (nodesWidth + 1)]
#define EDGE_W(i, j) edgesHoriz[(i) - 1 + (j) * (nodesWidth + 1)]
#define EDGE_E(i, j) edgesHoriz[(i) + (j) * (nodesWidth + 1)]
#define EDGE_SW(i, j) edgesRightDiag[(i) - 1 + (j) * (nodesWidth + 1)]
#define EDGE_S(i, j) edgesVert[(i) + (j) * (nodesWidth + 1)]
#define EDGE_SE(i, j) edgesLeftDiag[(i) + (j) * (nodesWidth + 1)]

struct Node {
    float g;
    uint dirNext_isStart;
    //int dirNext; // clockwise
    //int isStart;

    inline bool IsStart() { return dirNext_isStart >> 3;}
    inline uint GetDirNext() { return dirNext_isStart & 7; }
    inline void SetDirNext(uint dirNext) { dirNext_isStart = ((dirNext_isStart >> 3) << 3) | dirNext; }
};


CBUFFER_START(Params)
uint nodesWidth;
uint nodesHeight;
uint groupsX;
uint groupsY;
uint goalIndex;
CBUFFER_END


StructuredBuffer<Node> nodesRead;
RWStructuredBuffer<Node> nodesWrite;
StructuredBuffer<float> edgesVert;      //  | edges
StructuredBuffer<float> edgesHoriz;     //  — edges
StructuredBuffer<float> edgesLeftDiag;  //  \ edges
StructuredBuffer<float> edgesRightDiag; //  / edges
RWStructuredBuffer<int> exitFlagBuffer;
RWStructuredBuffer<float> maxAgentsGPerGroup;

groupshared float maxAgentsGShared;
groupshared uint maxAgentsGSharedAsUint = asuint(0.0);
groupshared uint repeatShared;
groupshared uint newMaxAgentsGSharedAsUint;
groupshared Node nodesReadShared[SHARED_ARRAYS_SIZE_X][SHARED_ARRAYS_SIZE_Y];

inline void ClampGlobalAndThreadIDToNodesBounds(inout uint3 threadId, inout uint3 globalId)
{
    uint3 clampedGlobalId = min(globalId, uint3(nodesWidth + 1, nodesHeight + 1, 0));
    threadId -= globalId - clampedGlobalId;
    globalId = clampedGlobalId;
}

inline void LoadToSharedMemory(uint3 globalId, uint3 threadId, uint flattenedThreadId) 
{
    ClampGlobalAndThreadIDToNodesBounds(threadId, globalId);
    nodesReadShared[threadId.x + 1][threadId.y + 1] = nodesRead[NODES_1D_INDEX(globalId.x, globalId.y)];
    // X is index of thread - flattenedThreadId - FTID
    // 0 -- GROUP_SIZE_X+1 => (X; 0)     // top halo row
    // GROUP_SIZE_X+2 -- 2*GROUP_SIZE_X+3 => (X - (GROUP_SIZE_X + 2); GROUP_SIZE_Y + 1) // bottom halo row
    // else ((X mod 2) * (GROUP_SIZE_X+1); (X - (2*GROUP_SIZE_X+4)) / 2)  // alternating left and right halo columns
#define FTID flattenedThreadId
    if(FTID < NUM_SHARED_HALO_NODES)
    {
        uint3 selector = uint3((FTID >= 0) & (FTID <= GROUP_SIZE_X + 1), 
                               (FTID >= GROUP_SIZE_X + 2) & (FTID <= 2 * GROUP_SIZE_X + 3), 
                               (FTID >= 2 * GROUP_SIZE_X + 4));

        uint haloThreadIdX = dot(selector, uint3(FTID, FTID - (GROUP_SIZE_X + 2), (FTID % 2) * (GROUP_SIZE_X + 1)));
        uint haloThreadIdY = dot(selector, uint3(0, GROUP_SIZE_Y + 1, 1 + (FTID - (2 * GROUP_SIZE_X + 4)) / 2));
        globalId += uint3(haloThreadIdX - 1, haloThreadIdY - 1, 0) - threadId;
        threadId = uint3(haloThreadIdX, haloThreadIdY, 0);
        ClampGlobalAndThreadIDToNodesBounds(threadId, globalId);
        nodesReadShared[threadId.x][threadId.y] = nodesRead[NODES_1D_INDEX(globalId.x, globalId.y)];
    }
#undef FTID
}

inline void CalcMaxAgentsG(uint threadFlattenedId)
{
    if(threadFlattenedId < groupsX * groupsY) 
    {
        InterlockedMax(maxAgentsGSharedAsUint, asuint(maxAgentsGPerGroup[threadFlattenedId]));
    }
}

inline void InitSharedVariables(uint3 globalId, uint3 threadId, uint flattenedThreadId) 
{
    LoadToSharedMemory(globalId, threadId, flattenedThreadId);
    CalcMaxAgentsG(flattenedThreadId);

    if((threadId.x == 0) & (threadId.y == 0)) 
    {
        maxAgentsGShared = asfloat(maxAgentsGSharedAsUint);
        newMaxAgentsGSharedAsUint = asuint(0.0);
        repeatShared = 0;
    }
}

inline void NodeSetDirNext(inout Node node, uint dirNext) 
{
    node.dirNext_isStart = ((node.dirNext_isStart >> 3) << 3) | dirNext;
}

inline Node ReadNodeAt2D(in int threadIdX, in int threadIdY) { return nodesReadShared[threadIdX + 1][threadIdY + 1]; }

inline void WriteNodeAt(in Node node, in int index) 
{
    nodesWrite[index] = node;
}

inline void WriteNodeAt2D(in Node node, in int i, in int j) { WriteNodeAt(node, NODES_1D_INDEX(i, j)); }

inline int ReplaceIfXLessThanY(in int value, in int replacement, in float x, in float y) 
{
    return lerp(value, replacement, (x < y));
}

inline void ProcessNeighbour(in float edge, inout Node node, in Node neighbour, in int dir, inout bool repeat)
{
    float oldG = node.g;
    float tentativeNewG = neighbour.g + edge;
    node.SetDirNext(ReplaceIfXLessThanY(node.GetDirNext(), dir, tentativeNewG, node.g));
    node.g = min(node.g, tentativeNewG);
    repeat = repeat | ((node.g != oldG) & (node.g < maxAgentsGShared));
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void WavefrontInitNodesKernel(uint3 id : SV_DispatchThreadID) 
{
    if((id.x <= nodesWidth + 1) & (id.y <= nodesHeight + 1)) 
    {
        uint index = NODES_1D_INDEX(id.x, id.y);
        Node node;
        node.g = index == goalIndex ? 0 : 1.#INF;
        node.dirNext_isStart = nodesRead[index].dirNext_isStart;
        nodesWrite[index] = node;
    }
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void WavefrontPlannerKernel (uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID,
    uint3 threadId : SV_GroupThreadID, uint threadFlattenedId : SV_GroupIndex)
{
    id.x++;
    id.y++;
    uint index = NODES_1D_INDEX(id.x, id.y);

    InitSharedVariables(id, threadId, threadFlattenedId);
    GroupMemoryBarrierWithGroupSync();

    if((id.x <= nodesWidth) & (id.y <= nodesHeight) & (index != goalIndex))
    {
        
        Node node = ReadNodeAt2D(threadId.x, threadId.y);
        bool repeat = false;
        ProcessNeighbour(EDGE_NW(id.x, id.y), node, ReadNodeAt2D(threadId.x - 1, threadId.y - 1), 0, repeat);
        ProcessNeighbour(EDGE_N(id.x, id.y),  node, ReadNodeAt2D(threadId.x,     threadId.y - 1), 1, repeat);
        ProcessNeighbour(EDGE_NE(id.x, id.y), node, ReadNodeAt2D(threadId.x + 1, threadId.y - 1), 2, repeat);
        ProcessNeighbour(EDGE_W(id.x, id.y),  node, ReadNodeAt2D(threadId.x - 1, threadId.y    ), 3, repeat);
        ProcessNeighbour(EDGE_E(id.x, id.y),  node, ReadNodeAt2D(threadId.x + 1, threadId.y    ), 4, repeat);
        ProcessNeighbour(EDGE_SW(id.x, id.y), node, ReadNodeAt2D(threadId.x - 1, threadId.y + 1), 5, repeat);
        ProcessNeighbour(EDGE_S(id.x, id.y),  node, ReadNodeAt2D(threadId.x,     threadId.y + 1), 6, repeat);
        ProcessNeighbour(EDGE_SE(id.x, id.y), node, ReadNodeAt2D(threadId.x + 1, threadId.y + 1), 7, repeat);
        WriteNodeAt(node, index);

        bool isUninitializedStart = node.IsStart() & isinf(node.g);
        InterlockedOr(repeatShared, repeat | isUninitializedStart);

        if(node.IsStart())
            InterlockedMax(newMaxAgentsGSharedAsUint, asuint((float)node.g));
    }

    GroupMemoryBarrierWithGroupSync();

    if((threadId.x == 0) & (threadId.y == 0)) 
    {
        maxAgentsGPerGroup[groupId.x + groupId.y * groupsX] = asfloat(newMaxAgentsGSharedAsUint);
        if(repeatShared)
            exitFlagBuffer[0] = 0;
    }
}