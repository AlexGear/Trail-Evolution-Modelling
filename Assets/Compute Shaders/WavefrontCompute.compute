#pragma kernel WavefrontPlannerKernel
#pragma kernel WavefrontInitNodesKernel

#include "HLSLSupport.cginc"

#define GROUP_SIZE_X 32
#define GROUP_SIZE_Y 8
#define SHARED_ARRAYS_SIZE_X (GROUP_SIZE_X + 2)
#define SHARED_ARRAYS_SIZE_Y (GROUP_SIZE_Y + 2)
#define SHARED_ARRAYS_SIZE (SHARED_ARRAYS_SIZE_X * SHARED_ARRAYS_SIZE_Y)
#define NUM_SHARED_HALO_NODES (2 * (GROUP_SIZE_X + GROUP_SIZE_Y + 2))

#define NODES_WIDTH_INCLUDING_HALO (nodesWidth + 2)
#define NODES_1D_INDEX(i, j) ((i) + NODES_WIDTH_INCLUDING_HALO * (j))

#define EDGE_NW(i, j) edgesLeftDiag[(i) - 1 + ((j) - 1) * (nodesWidth + 1)]
#define EDGE_N(i, j) edgesVert[(i) + ((j) - 1) * (nodesWidth + 1)]
#define EDGE_NE(i, j) edgesRightDiag[(i) + ((j) - 1) * (nodesWidth + 1)]
#define EDGE_W(i, j) edgesHoriz[(i) - 1 + (j) * (nodesWidth + 1)]
#define EDGE_E(i, j) edgesHoriz[(i) + (j) * (nodesWidth + 1)]
#define EDGE_SW(i, j) edgesRightDiag[(i) - 1 + (j) * (nodesWidth + 1)]
#define EDGE_S(i, j) edgesVert[(i) + (j) * (nodesWidth + 1)]
#define EDGE_SE(i, j) edgesLeftDiag[(i) + (j) * (nodesWidth + 1)]

struct Node {
    float g;
    int dirNext; // clockwise
    int isStart;
};


CBUFFER_START(Params)
//uint readNodesIndex;
uint nodesWidth;
uint nodesHeight;
uint groupsX;
uint groupsY;
uint goalIndex;
//float maxAgentsG;
CBUFFER_END


//RWStructuredBuffer<Node> nodesBuffer0;
//RWStructuredBuffer<Node> nodesBuffer1;
StructuredBuffer<Node> nodesRead;
RWStructuredBuffer<Node> nodesWrite;
StructuredBuffer<float> edgesVert;      //  | edges
StructuredBuffer<float> edgesHoriz;     //  — edges
StructuredBuffer<float> edgesLeftDiag;  //  \ edges
StructuredBuffer<float> edgesRightDiag; //  / edges
RWStructuredBuffer<int> exitFlagBuffer;
RWStructuredBuffer<float> maxAgentsGPerGroup;

groupshared float maxAgentsGShared;
groupshared uint maxAgentsGSharedAsUint = asuint(0.0);
groupshared uint repeatShared;
groupshared uint newMaxAgentsGSharedAsUint;
groupshared Node nodesReadShared[SHARED_ARRAYS_SIZE_X][SHARED_ARRAYS_SIZE_Y];
//groupshared float edgesVertShared[SHARED_ARRAYS_SIZE];
//groupshared float edgesHorizShared[SHARED_ARRAYS_SIZE];
//groupshared float edgesLeftDiagShared[SHARED_ARRAYS_SIZE];
//groupshared float edgesRightDiagShared[SHARED_ARRAYS_SIZE];

inline void ClampGlobalAndThreadIDToNodesBounds(inout uint3 threadId, inout uint3 globalId)
{
    uint3 clampedGlobalId = min(globalId, uint3(nodesWidth + 1, nodesHeight + 1, 0));
    threadId -= globalId - clampedGlobalId;
    globalId = clampedGlobalId;
}

inline void LoadToSharedMemory(uint3 globalId, uint3 threadId, uint flattenedThreadId) 
{
    //if(threadId.x == 0 && threadId.y == 0) {
    //    for(uint i = 0; i <= GROUP_SIZE_X+1; i++) {
    //        for(uint j = 0; j <= GROUP_SIZE_Y+1; j++) {
    //            uint3 t = uint3(i, j, 0);
    //            uint3 g = globalId + uint3(i - 1, j - 1, 0);
    //            ClampGlobalAndThreadIDToNodesBounds(t, g);
    //            nodesReadShared[t.x][t.y] = nodesRead[NODES_1D_INDEX(g.x, g.y)];
    //        }
    //    }
    //}

    ClampGlobalAndThreadIDToNodesBounds(threadId, globalId);
    nodesReadShared[threadId.x + 1][threadId.y + 1] = nodesRead[NODES_1D_INDEX(globalId.x, globalId.y)];
    // 0 -- GROUP_SIZE_X+1 => (X; 0)
    // GROUP_SIZE_X+2 -- 2*GROUP_SIZE_X+3 => (X - (GROUP_SIZE_X + 2); GROUP_SIZE_Y + 1)
    // else ((X mod 2) * (GROUP_SIZE_X+1); (X - (2*GROUP_SIZE_X+4)) / 2)
#define FTID flattenedThreadId
    if(FTID < NUM_SHARED_HALO_NODES)
    {
        uint3 selector = uint3((FTID >= 0) & (FTID <= GROUP_SIZE_X + 1), 
                               (FTID >= GROUP_SIZE_X + 2) & (FTID <= 2 * GROUP_SIZE_X + 3), 
                               (FTID >= 2 * GROUP_SIZE_X + 4));

        uint haloThreadIdX = dot(selector, uint3(FTID, FTID - (GROUP_SIZE_X + 2), (FTID % 2) * (GROUP_SIZE_X + 1)));
        uint haloThreadIdY = dot(selector, uint3(0, GROUP_SIZE_Y + 1, 1 + (FTID - (2 * GROUP_SIZE_X + 4)) / 2));
        globalId += uint3(haloThreadIdX - 1, haloThreadIdY - 1, 0) - threadId;
        threadId = uint3(haloThreadIdX, haloThreadIdY, 0);
        ClampGlobalAndThreadIDToNodesBounds(threadId, globalId);
        nodesReadShared[threadId.x][threadId.y] = nodesRead[NODES_1D_INDEX(globalId.x, globalId.y)];
    }
#undef FTID
    GroupMemoryBarrierWithGroupSync();
}

inline void CalcMaxAgentsG(uint threadFlattenedId)
{
    if(threadFlattenedId < groupsX * groupsY) 
    {
        InterlockedMax(maxAgentsGSharedAsUint, asuint(maxAgentsGPerGroup[threadFlattenedId]));
    }
}

//inline Node ReadNodeAt(in int index) 
//{
//    //if(readNodesIndex == 0)
//    //    return nodesBuffer0[index];
//    //return nodesBuffer1[index];
//    return nodesRead[index];
//}

inline Node ReadNodeAt2D(in int threadIdX, in int threadIdY) { return nodesReadShared[threadIdX + 1][threadIdY + 1]; }

inline void WriteNodeAt(in Node node, in int index) 
{
    //if(readNodesIndex == 0)
    //    nodesBuffer1[index] = node;
    //else
    //    nodesBuffer0[index] = node;
    nodesWrite[index] = node;
}

inline void WriteNodeAt2D(in Node node, in int i, in int j) { WriteNodeAt(node, NODES_1D_INDEX(i, j)); }

inline void ReplaceIfXLessThanY(inout int value, in int replacement, in float x, in float y) 
{
    // step(y, x) == (x < y) ? 0 : 1
    value = lerp(value, replacement, 1 - step(y, x));
    //if(x < y)
    //    value = replacement;
}

inline void ProcessNeighbour(in float edge, inout Node node, in Node neighbour, in int dir, inout bool repeat)
{
    float newG = neighbour.g + edge;
    ReplaceIfXLessThanY(node.dirNext, dir, newG, node.g);
    float old = node.g;
    node.g = min(node.g, newG);
    bool changed = node.g != old;
    repeat = repeat | (changed & (node.g < maxAgentsGShared));
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void WavefrontInitNodesKernel(uint3 id : SV_DispatchThreadID) 
{
    if((id.x <= nodesWidth + 1) & (id.y <= nodesHeight + 1)) 
    {
        uint index = NODES_1D_INDEX(id.x, id.y);
        Node node;
        node.g = index == goalIndex ? 0 : 1.#INF;
        node.dirNext = 0;
        node.isStart = nodesRead[index].isStart;

        //nodesBuffer0[index] = node;
        //nodesBuffer1[index] = node;
        //nodesRead[index] = node;
        nodesWrite[index] = node;
    }
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void WavefrontPlannerKernel (uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID,
    uint3 threadId : SV_GroupThreadID, uint threadFlattenedId : SV_GroupIndex)
{
    id.x++;
    id.y++;
    uint index = NODES_1D_INDEX(id.x, id.y);

    LoadToSharedMemory(id, threadId, threadFlattenedId);
    CalcMaxAgentsG(threadFlattenedId);

    if((threadId.x == 0) & (threadId.y == 0)) 
    {
        maxAgentsGShared = asfloat(maxAgentsGSharedAsUint);
        newMaxAgentsGSharedAsUint = asuint(0.0);
        repeatShared = 0;
    }

    GroupMemoryBarrierWithGroupSync();

    if((id.x <= nodesWidth) & (id.y <= nodesHeight) & (index != goalIndex))
    {

        Node node = ReadNodeAt2D(threadId.x, threadId.y);
        bool repeat = false;
        ProcessNeighbour(EDGE_NW(id.x, id.y), node, ReadNodeAt2D(threadId.x - 1, threadId.y - 1), 0, repeat);
        ProcessNeighbour(EDGE_N(id.x, id.y),  node, ReadNodeAt2D(threadId.x,     threadId.y - 1), 1, repeat);
        ProcessNeighbour(EDGE_NE(id.x, id.y), node, ReadNodeAt2D(threadId.x + 1, threadId.y - 1), 2, repeat);
        ProcessNeighbour(EDGE_W(id.x, id.y),  node, ReadNodeAt2D(threadId.x - 1, threadId.y    ), 3, repeat);
        ProcessNeighbour(EDGE_E(id.x, id.y),  node, ReadNodeAt2D(threadId.x + 1, threadId.y    ), 4, repeat);
        ProcessNeighbour(EDGE_SW(id.x, id.y), node, ReadNodeAt2D(threadId.x - 1, threadId.y + 1), 5, repeat);
        ProcessNeighbour(EDGE_S(id.x, id.y),  node, ReadNodeAt2D(threadId.x,     threadId.y + 1), 6, repeat);
        ProcessNeighbour(EDGE_SE(id.x, id.y), node, ReadNodeAt2D(threadId.x + 1, threadId.y + 1), 7, repeat);
        WriteNodeAt(node, index);

        bool isUninitializedStart = node.isStart & isinf(node.g);
        InterlockedOr(repeatShared, repeat | isUninitializedStart);

        if(node.isStart)
            InterlockedMax(newMaxAgentsGSharedAsUint, asuint(node.g));
    }

    GroupMemoryBarrierWithGroupSync();

    if((threadId.x == 0) & (threadId.y == 0)) 
    {
        maxAgentsGPerGroup[groupId.x + groupId.y * groupsX] = asfloat(newMaxAgentsGSharedAsUint);
        if(repeatShared)
            exitFlagBuffer[0] = 0;
    }
}